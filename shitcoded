-- JobId Bypass Script for Delta Executor
-- This script attempts multiple methods to retrieve the original JobId

local function debugPrint(method, result)
    print("[DEBUG] " .. method .. ": " .. tostring(result))
end

-- Method 1: Memory Scanning for JobId Pattern
local function memoryJobIdScan()
    local success, result = pcall(function()
        -- Scan for JobId pattern in memory using getgc
        local objects = getgc(true)
        local jobIdPattern = "%w+-%w+-%w+-%w+-%w+" -- UUID pattern
        
        for i, obj in pairs(objects) do
            if type(obj) == "string" and string.match(obj, jobIdPattern) then
                -- Check if it's a valid JobId format (not the spoofed one)
                if string.len(obj) == 36 and string.sub(obj, 9, 9) == "-" then
                    -- Additional validation to ensure it's not the known fake
                    local segments = string.split(obj, "-")
                    if #segments == 5 then
                        return obj
                    end
                end
            end
        end
        return nil
    end)
    
    if success and result then
        debugPrint("Memory Scan", result)
        return result
    end
    return nil
end

-- Method 2: CoreGui JobId Retrieval
local function coreGuiJobId()
    local success, result = pcall(function()
        local CoreGui = game:GetService("CoreGui")
        -- Try to access JobId through CoreGui's internal references
        local robloxGui = CoreGui:FindFirstChild("RobloxGui")
        if robloxGui then
            -- Look for JobId in RobloxGui's properties or descendants
            for _, child in pairs(robloxGui:GetDescendants()) do
                if child:IsA("StringValue") and child.Name:lower():find("job") then
                    return child.Value
                end
            end
        end
        return nil
    end)
    
    if success and result then
        debugPrint("CoreGui Method", result)
        return result
    end
    return nil
end

-- Method 3: Raw Memory Access via rawget on DataModel
local function rawDataModelAccess()
    local success, result = pcall(function()
        -- Use rawget to bypass metamethod hooks
        local dm = game
        local jobId = rawget(dm, "JobId")
        
        if not jobId then
            -- Try accessing through getfenv or debug library
            local env = getfenv(0)
            for k, v in pairs(env) do
                if tostring(k):lower():find("job") and type(v) == "string" then
                    return v
                end
            end
        end
        
        return jobId
    end)
    
    if success and result then
        debugPrint("Raw DataModel", result)
        return result
    end
    return nil
end

-- Method 4: HttpService Internal State Access
local function httpServiceJobId()
    local success, result = pcall(function()
        local HttpService = game:GetService("HttpService")
        
        -- Try to access internal state of HttpService
        local internalState = rawget(HttpService, "_internal") or rawget(HttpService, "state")
        
        if internalState then
            for k, v in pairs(internalState) do
                if type(v) == "string" and string.match(v, "%w+-%w+-%w+-%w+-%w+") then
                    return v
                end
            end
        end
        
        -- Alternative: use debug.getregistry to find JobId
        local registry = debug.getregistry()
        for k, v in pairs(registry) do
            if type(v) == "string" and string.match(v, "%w+-%w+-%w+-%w+-%w+") then
                if string.len(v) == 36 then
                    return v
                end
            end
        end
        
        return nil
    end)
    
    if success and result then
        debugPrint("HttpService Method", result)
        return result
    end
    return nil
end

-- Method 5: Network Layer JobId Extraction
local function networkLayerJobId()
    local success, result = pcall(function()
        -- Hook into lower-level network functions
        local originalRequest = request or http_request or syn.request
        
        if originalRequest then
            -- Monitor outgoing requests for JobId
            local hookedRequest = hookfunction(originalRequest, function(options)
                local response = originalRequest(options)
                
                -- Check response headers and body for JobId
                if response and response.Body then
                    local jobIdMatch = string.match(response.Body, '"jobId":"([^"]+)"')
                    if jobIdMatch then
                        return jobIdMatch
                    end
                end
                
                return response
            end)
        end
        
        return nil
    end)
    
    if success and result then
        debugPrint("Network Layer", result)
        return result
    end
    return nil
end

-- Method 6: Deep Registry Dive
local function registryDeepDive()
    local success, result = pcall(function()
        local registry = debug.getregistry()
        
        -- Look for hidden or internal JobId references
        local function searchTable(tbl, depth)
            if depth > 5 then return nil end
            
            for k, v in pairs(tbl) do
                if type(v) == "string" then
                    if string.match(v, "^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$") then
                        -- Found UUID pattern, validate it's not the fake one
                        return v
                    end
                elseif type(v) == "table" and depth < 3 then
                    local found = searchTable(v, depth + 1)
                    if found then return found end
                end
            end
            return nil
        end
        
        return searchTable(registry, 0)
    end)
    
    if success and result then
        debugPrint("Registry Deep Dive", result)
        return result
    end
    return nil
end

-- Method 7: Reflection-based JobId Access
local function reflectionJobId()
    local success, result = pcall(function()
        -- Use reflection to access private members
        local DataModel = game
        
        -- Try to get the metatable and access original methods
        local mt = getrawmetatable(DataModel)
        local originalIndex = rawget(mt, "__index")
        
        if originalIndex then
            -- Temporarily unhook to get original value
            setreadonly(mt, false)
            rawset(mt, "__index", nil)
            
            local originalJobId = DataModel.JobId
            
            -- Restore the hook
            rawset(mt, "__index", originalIndex)
            setreadonly(mt, true)
            
            return originalJobId
        end
        
        return nil
    end)
    
    if success and result then
        debugPrint("Reflection Method", result)
        return result
    end
    return nil
end

-- Method 8: Environment Variable Extraction
local function envJobIdExtraction()
    local success, result = pcall(function()
        -- Check various environment sources
        local env = getfenv(0)
        local globalEnv = getfenv(1)
        
        -- Check _G for any JobId references
        for k, v in pairs(_G) do
            if type(v) == "string" and string.match(v, "%w+-%w+-%w+-%w+-%w+") then
                if string.len(v) == 36 then
                    return v
                end
            end
        end
        
        -- Check shared table if available
        if shared then
            for k, v in pairs(shared) do
                if type(v) == "string" and string.match(v, "%w+-%w+-%w+-%w+-%w+") then
                    if string.len(v) == 36 then
                        return v
                    end
                end
            end
        end
        
        return nil
    end)
    
    if success and result then
        debugPrint("Environment Extraction", result)
        return result
    end
    return nil
end

-- Main bypass function
local function getOriginalJobId()
    print("=== Starting JobId Bypass Attempts ===")
    
    local methods = {
        {"Memory Scanning", memoryJobIdScan},
        {"CoreGui Access", coreGuiJobId},
        {"Raw DataModel", rawDataModelAccess},
        {"HttpService Internal", httpServiceJobId},
        {"Network Layer", networkLayerJobId},
        {"Registry Deep Dive", registryDeepDive},
        {"Reflection", reflectionJobId},
        {"Environment Variables", envJobIdExtraction}
    }
    
    for i, methodData in ipairs(methods) do
        local methodName, methodFunc = methodData[1], methodData[2]
        print("Trying method " .. i .. ": " .. methodName)
        
        local result = methodFunc()
        if result and result ~= game.JobId then
            print("SUCCESS! Found potential original JobId: " .. result)
            print("Spoofed JobId: " .. tostring(game.JobId))
            return result
        end
    end
    
    print("All methods failed. The spoofer might be very sophisticated.")
    return nil
end

-- Debug script to compare environments
local function compareEnvironments()
    print("=== Environment Comparison ===")
    print("Current JobId: " .. tostring(game.JobId))
    print("DataModel type: " .. typeof(game))
    
    -- Check if JobId is hooked
    local mt = getrawmetatable(game)
    if mt then
        print("DataModel has metatable: true")
        print("Metatable readonly: " .. tostring(isreadonly(mt)))
        
        if rawget(mt, "__index") then
            print("__index hook detected: true")
        end
        
        if rawget(mt, "__newindex") then
            print("__newindex hook detected: true")
        end
    end
    
    -- Check for common executor globals
    local executorGlobals = {"hookfunction", "setreadonly", "getrawmetatable", "rawget", "rawset", "getgc", "debug"}
    for _, global in ipairs(executorGlobals) do
        print(global .. " available: " .. tostring(_G[global] ~= nil))
    end
end
